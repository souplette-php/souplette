{#
    @see https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
#}
{% import 'tokenizer/_macros.php.twig' as h -%}

// Consume the maximum number of characters possible,
// with the consumed characters matching one of the identifiers of the named character references table (in a case-sensitive manner).
// Append each character to the temporary buffer when it's consumed.
$pos = $this->position;
$node = $this->entitySearch;
$buffer = '';
// Consume characters and compare these to a substring of the entity names until the substring no longer matches.
while (true) {
    $c = $this->input[$pos] ?? null;
    if ($c === null) break;
    if (!isset($node->children[$c])) break;
    $node = $node->children[$c];
    $buffer .= $c;
    $pos++;
}
// At this point we have a string that starts with some characters that may match an entity
// Try to find the longest entity the string will match to take care of &noti for instance.
$node = $this->entitySearch;
$lastTerminalIndex = null;
for ($i = 0, $l = strlen($buffer); $i < $l; $i++) {
    $c = $buffer[$i];
    if (!isset($node->children[$c])) break;
    $node = $node->children[$c];
    if ($node->value) $lastTerminalIndex = $i;
}
if ($lastTerminalIndex !== null) {
    $buffer = substr($buffer, 0, $lastTerminalIndex + 1);
    $this->position += $lastTerminalIndex + 1;
    if (
        // If the character reference was consumed as part of an attribute,
        ({{ h.is_attribute_return_state() }})
        // and the last character matched is not a U+003B SEMICOLON character (;),
        && $buffer[-1] !== ';'
        // and the next input character is either a U+003D EQUALS SIGN character (=) or an ASCII alphanumeric,
        && 1 === strspn($this->input, '='.Characters::ALNUM, $this->position, 1)
    ) {
        // then, for historical reasons, flush code points consumed as a character reference
        $this->temporaryBuffer .= $buffer;
        $this->flushCodePointsConsumedAsACharacterReference();
        // and switch to the return state.
        {{ h.reconsume_in_return_state() }}
    } else {
        // Otherwise:
        // 1. If the last character matched is not a U+003B SEMICOLON character (;),
        if ($buffer[-1] !== ';') {
            // This is a missing-semicolon-after-character-reference parse error.
            {{ h.parse_error('MISSING_SEMICOLON_AFTER_CHARACTER_REFERENCE') }}
        }
        // 2. Set the temporary buffer to the empty string. Append the decoded character reference to the temporary buffer.
        $this->temporaryBuffer = EntityLookup::NAMED_ENTITIES[$buffer];
        // 3. Flush code points consumed as a character reference.
        $this->flushCodePointsConsumedAsACharacterReference();
        // Switch to the return state.
        {{ h.reconsume_in_return_state() }}
    }
} else {
    $this->temporaryBuffer = '&';
    // Flush code points consumed as a character reference.
    $this->flushCodePointsConsumedAsACharacterReference();
    // Switch to the ambiguous ampersand state.
    {{ h.reconsume_in('AMBIGUOUS_AMPERSAND') }}
}
